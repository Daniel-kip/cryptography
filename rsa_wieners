#!/usr/bin/env python3
import gmpy2
from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes

def wiener_attack_demo():
    print("=== RSA WIENER'S ATTACK DEMO (Corrected) ===")

    # 1. SETUP: Generate a vulnerable RSA keypair
    nbits = 1024
    p = getPrime(nbits // 2)
    q = getPrime(nbits // 2)
    n = p * q
    phi = (p - 1) * (q - 1)

    # d must be small: d < (1/3) * n^(1/4)
    d = getPrime(nbits // 4 - 10) 
    e = int(gmpy2.invert(d, phi))

    message = b"WIENER_ATTACK_SUCCESS"
    m = bytes_to_long(message)
    c = pow(m, e, n)

    print(f"\n[Phase 1] Setup complete.")
    print(f"  [+] Public Key (e, n) generated.")
    print(f"  [!] Target d: {d}")

    # 2. THE ATTACK: Continued Fractions via Euclidean Algorithm
    print(f"\n[Phase 2] Computing Continued Fraction Convergents...")

    def get_convergents(e, n):
        # Step A: Get continued fraction coefficients [a0, a1, a2...]
        cf = []
        a, b = e, n
        while b:
            q, r = divmod(a, b)
            cf.append(q)
            a, b = b, r
        
        # Step B: Generate convergents k/d
        convergents = []
        n0, d0 = 0, 1 # Numerator and denominator of convergent i-2
        n1, d1 = 1, 0 # Numerator and denominator of convergent i-1
        
        for x in cf:
            # Standard recurrence relation for convergents
            ni = x * n1 + n0
            di = x * d1 + d0
            convergents.append((ni, di))
            n0, n1 = n1, ni
            d0, d1 = d1, di
        return convergents

    convergents = get_convergents(e, n)
    print(f"  [*] Calculated {len(convergents)} candidates for d.")

    # 3. VERIFICATION
    print(f"\n[Phase 3] Testing d candidates...")
    
    recovered_d = None
    for k, potential_d in convergents:
        if potential_d == 0: continue
        
        # Quick test: Use a small known value to see if d works
        if pow(pow(2, e, n), potential_d, n) == 2:
            recovered_d = potential_d
            print(f"  [!] Found the Private Key! d = {recovered_d}")
            break

    if recovered_d:
        decrypted_msg = long_to_bytes(pow(c, recovered_d, n))
        print(f"\n[RESULT] Decrypted Message: {decrypted_msg.decode()}")
    else:
        print("\n[-] Attack failed. d might be too large for this attack.")

if __name__ == "__main__":
    wiener_attack_demo()
