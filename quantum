#!/usr/bin/env python3
import math
import random
from fractions import Fraction

def classical_order_finding(a, N):
    """Find smallest r such that a^r ≡ 1 mod N"""
    # Classical simulation of quantum order finding
    r = 1
    while pow(a, r, N) != 1:
        r += 1
    return r

def shor_algorithm_simulation(N):
    """Simulate Shor's algorithm conceptually"""
    
    print(f"[*] Attempting to factor N = {N}")
    print("[*] (Classical simulation of quantum algorithm)")
    
    if N % 2 == 0:
        return 2
    
    # Step 1: Choose random a
    a = random.randint(2, N-1)
    print(f"[*] Random a = {a}")
    
    # Step 2: Compute gcd
    g = math.gcd(a, N)
    if g > 1:
        print(f"[!] Lucky guess! Found factor: {g}")
        return g
    
    # Step 3: Find order (QUANTUM STEP - simulated classically)
    print("[*] Finding order r such that a^r ≡ 1 mod N...")
    r = classical_order_finding(a, N)
    print(f"[*] Found r = {r}")
    
    # Step 4: Check if r is even
    if r % 2 != 0:
        print("[*] r is odd, retrying...")
        return None
    
    # Step 5: Compute factors
    candidate = pow(a, r//2, N)
    p = math.gcd(candidate - 1, N)
    q = math.gcd(candidate + 1, N)
    
    if p * q == N:
        print(f"[!] FACTORED: {N} = {p} × {q}")
        return p
    else:
        print("[*] Failed, retrying...")
        return None

# Try to factor 21
result = shor_algorithm_simulation(21)
print("\n[*] Implications:")
print("    - Quantum computers would break RSA in polynomial time")
print("    - This is why we need Post-Quantum Cryptography")
print("    - NIST has standardized Kyber and Dilithium")
